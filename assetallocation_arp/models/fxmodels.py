"""Created on Sun Jun  14 15:47:00 2020FX Models@author:"""import numpy as npimport pandas as pdimport itertoolsfrom assetallocation_arp.models import portfolio_construction as pcfrom assetallocation_arp.data_etl.dal.data_frame_converter import DataFrameConverterdef format_data(strategy: 'Fx'):    """    creating dataframes with spot and carry indices, cash rates and ppp levels    :param Fx strategy:    :return: dataframes with formatted series for spot and carry indices, cash rates and ppp levels    """    # spot assets are linked to ppp by currency    currency_combinations = list(itertools.combinations([i.currency for i in strategy.asset_inputs], 2))    combined_currencies = [''.join(i) for i in currency_combinations]    spot = [analytic for asset in strategy.spot_assets for analytic in asset.asset_analytics]    spot = DataFrameConverter.asset_analytics_to_df(spot)    spot = spot.asfreq('BM')    spot.columns = spot.columns.str[:6]    carry = [analytic for asset in strategy.carry_assets for analytic in asset.asset_analytics]    carry = DataFrameConverter.asset_analytics_to_df(carry)    carry = carry.asfreq('BM')    carry.columns = carry.columns.str[:6]    # deriving ppp and cash rates for the crosses    ppp = [(asset_input.currency, analytic) for asset_input in strategy.asset_inputs for analytic           in asset_input.ppp_asset.asset_analytics]    ppp = DataFrameConverter.asset_analytics_to_currency_df(ppp)    ppp = ppp.asfreq('BM')    cash = [(asset_input.currency, analytic) for asset_input in strategy.asset_inputs for analytic            in asset_input.cash_rate_asset.asset_analytics]    cash = DataFrameConverter.asset_analytics_to_currency_df(cash)    cash = cash.asfreq('BM')    fx = np.array(currency_combinations).T    ppp_n = ppp.loc[:, fx[1]].to_numpy() / ppp.loc[:, fx[0]].to_numpy()    ppp_n = pd.DataFrame(data=ppp_n, index=carry.index, columns=combined_currencies)    cash_n = cash.loc[:, fx[0]].to_numpy() - cash.loc[:, fx[1]].to_numpy()    cash_n = pd.DataFrame(data=cash_n, index=carry.index, columns=combined_currencies)    return spot, carry, cash_n, ppp_ndef calculate_signals(fx: 'Fx', spot, carry, cash, ppp):    """    creating dataframes with spot and carry indices, cash rates and ppp levels    :param Fx fx: strategy object    :param pd.DataFrame spot: currency spot indices    :param pd.DataFrame carry: currency carry indices    :param pd.DataFrame cash: currency cash rates    :param pd.DataFrame ppp: currency ppp levels    :return: dataframes with model signals and historical volatility of the currency crosses    """    # calculate rolling volatility and sharpe ratios    if pd.notnull(fx.vol_window):        volatility = (12 ** 0.5) * carry.pct_change().rolling(fx.vol_window).std()    else:        volatility = 1    if pd.isnull(fx.historical_base):        fx.historical_base = 0    sharpe = (np.log(carry / carry.shift(int(fx.value_window - fx.historical_base / 2)).rolling(        fx.historical_base + 1).mean()) + 1) ** (12 / fx.value_window) - 1    # signal creation for various fx models    if fx.signal == 'momentum':        mom = 0        for i in range(0, len(fx.momentum_weights)):            mom = mom + (carry.shift(i) / carry.shift(i + 1) - 1) * fx.momentum_weights[i]        signal = ((1 + mom / sum(fx.momentum_weights)) ** 12 - 1) / volatility    elif fx.signal == 'carry':        signal = cash / volatility    elif fx.signal == 'dynamic hedge':        signal = (1 / 100) * (cash - ((1 + sharpe) ** (fx.value_window / 12) - 1) * fx.mean_reversion) / volatility    elif fx.signal == 'ppp':        signal = 100 * (ppp.shift(fx.value_window) / spot - 1)    else:        signal = 100 * (ppp.shift(fx.value_window) / spot - 1) / fx.mean_reversion + cash    # limited to base currency only yes/no    if pd.notnull(fx.currency):        signal = signal.mul(signal.columns.str.contains(fx.currency), axis=1)    # value cut off yes/no    if pd.notnull(fx.sharpe_cutoff):        # cond1 = np.sign(signal) == np.sign(sharpe)        cond1 = np.abs(signal + sharpe) == np.abs(signal) + np.abs(sharpe)        cond2 = np.abs(sharpe / volatility) > fx.sharpe_cutoff        signal = (1 - (cond1 & cond2)) * signal    # response function for momentum signals yes/no    if fx.response_function:        signal = signal * np.exp(-(np.abs(signal) ** 2 / 4))    # shorting the dataframes    start_date = signal.first_valid_index()    signal = signal[start_date:]    if isinstance(volatility, pd.DataFrame):        volatility = volatility[start_date:]    return signal, volatilitydef determine_sizing(fx: 'Fx', signal, volatility):    """    creating dataframes with currency exposures    :param Fx fx: strategy object    :param pd.DataFrame signal: model signals    :param pd.DataFrame or Int volatility: historical volatility of the currency crosses    :return: dataframes with currency exposures for individual crosses and aggregated    """    # reading inputs    fx_list = [i.currency for i in fx.asset_inputs]    # calculating exposures    if fx.signal == 'momentum' or fx.signal == 'carry':        signal_rank = np.abs(signal).rank(axis=1, method='first', ascending=False)        exposure = (signal_rank <= fx.top_crosses) * np.sign(signal).astype(float)        exposure_vol = np.abs(exposure) * (1 / volatility)        exposure = np.sign(exposure) * pc.cap_and_redistribute((exposure_vol.T / exposure_vol.sum(axis=1)).T, 0.5)    elif fx.signal == 'ppp':        signal_rank = np.abs(signal).rank(axis=1, method='first', ascending=False)        exposure = (signal_rank <= fx.top_crosses) * np.sign(signal).astype(float) / fx.top_crosses    else:        map = create_sizing_mapping()        exposure = signal.applymap(lambda x: map.index[(x >= map).sum() - 1].item())        exposure = fx.exposure * exposure * signal.notna().replace(False, np.nan)    # calculating aggregate exposures per currency    exposure_agg_strong = pd.DataFrame(index=exposure.index, columns=fx_list)    exposure_agg_weak = pd.DataFrame(index=exposure.index, columns=fx_list)    for x in fx_list[:len(fx_list)-1]:        exposure_agg_strong[x] = exposure.groupby(exposure.columns.str[:3] == x, axis=1).sum()[True].fillna(0)    for x in fx_list[1:]:        exposure_agg_weak[x] = exposure.groupby(exposure.columns.str[3:] == x, axis=1).sum()[True]    exposure_agg = exposure_agg_strong.fillna(0) - exposure_agg_weak.fillna(0)    return exposure, exposure_aggdef create_sizing_mapping():    map_return = np.append(-1, np.arange(-0.05, 0.055, 0.005)).round(4)    map_weight = np.append(np.arange(-0.05, 0.005, 0.005), np.arange(0, 0.055, 0.005)).round(4)    map = pd.DataFrame(data=map_return, index=map_weight, columns=['weight'])    return mapdef calculate_returns(fx: 'Fx', carry, signal, exposure, exposure_agg):    """    creating dataframes with model returns and currency contributions    :param pd.DataFrame fxmodels_inputs: parameter choices for the models    :param pd.DataFrame carry: currency carry indices    :param pd.DataFrame signal: model signals    :param pd.DataFrame exposure: currency exposure for individual crosses    :param pd.DataFrame exposure_agg: currency exposure aggregated    :return: dataframes with model returns, currency contributions and returns    """    # reading inputs    returns = pd.DataFrame(index=exposure.index)    # return calculations    returns['returns'] = (exposure.shift() * (carry / carry.shift()-1)).sum(axis=1)    returns['returns_cum'] = (1 + returns['returns']).cumprod() * 100    returns['turnover'] = (exposure_agg - exposure_agg.shift()).abs().sum(axis=1) / 2    transaction_costs = returns['turnover'] * fx.transaction_cost / 10000    returns['returns_net_cum'] = (1 + returns['returns'] - transaction_costs.shift()).cumprod() * 100    returns['returns_net_cum'][0] = 100    returns['strength_of_signal'] = (exposure * signal).sum(axis=1)    # getting return series vs base currency    carry_base = pd.DataFrame(index=exposure.index, columns=exposure_agg.columns)    if pd.isnull(fx.currency):        fx.currency = 'USD'    fx_base = exposure_agg.columns + fx.currency    for x in fx_base:        if carry.columns.contains(x):            carry_base[x[:3]] = carry[x]        elif x == fx.currency + fx.currency:            carry_base[fx.currency] = 1        else:            carry_base[x[:3]] = 1 / carry[fx.currency + x[:3]]    # contribution calculations    contribution = (exposure_agg.shift() * np.log(carry_base / carry_base.shift())).cumsum()    return returns, contribution, carry_base